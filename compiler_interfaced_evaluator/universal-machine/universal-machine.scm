(define univ-machine-ops-table
  (list
   ;; I/O
   (list 'read read)
   (list 'display display)
   (list 'prompt-for-input prompt-for-input)
   (list 'announce-output announce-output)
   (list 'user-print user-print)
   ;; Performance monitoring
   (list 'initialize-instruction-counter initialize-instruction-counter)
   (list 'initialize-stacks initialize-stacks)
   (list 'print-instruction-counter print-instruction-counter)
   (list 'print-stack-statistics print-stack-statistics)
   ;; Compilation
   (list 'make-compiled-procedure make-compiled-procedure)
   ;; Symbol processing
   (list 'symbol? symbol?)
   (list 'eq? eq?)
   ;; List processing
   (list 'list list)
   (list 'cons cons)
   ;; Arithmetic
   (list '= =)
   (list '+ +)
   (list '- -)
   (list '* *)
   (list '/ /)
   (list '< <)
   (list '> >)
   ;; Environments
   (list 'the-global-environment the-global-environment)
   (list 'get-global-environment get-global-environment)
   (list 'extend-environment extend-environment)
   (list 'define-variable! define-variable!)
   (list 'lookup-variable-value lookup-variable-value)
   (list 'set-variable-value! set-variable-value!)
   (list 'lexical-address-lookup lexical-address-lookup)
   (list 'lexical-address-set! lexical-address-set!)
   ;; Self-evaluating expressions
   (list 'self-evaluating? self-evaluating?)
   ;; Variables
   (list 'variable? variable?)
   ;; Quotations
   (list 'quoted? quoted?)
   (list 'text-of-quotation text-of-quotation)
   ;; Assignments
   (list 'make-assignment make-assignment)
   (list 'assignment? assignment?)
   (list 'assignment-variable assignment-variable)
   (list 'assignment-value assignment-value)
   ;; Definitions
   (list 'definition? definition?)
   (list 'definition-variable definition-variable)
   (list 'definition-value definition-value)
   ;; Conditionals
   (list 'if? if?)
   (list 'if-predicate if-predicate)
   (list 'if-consequent if-consequent)
   (list 'if-alternative if-alternative)
   (list 'true? true?)
   (list 'false? false?)
   ;; Lambdas
   (list 'make-procedure make-procedure)
   (list 'lambda? lambda?)
   (list 'lambda-parameters lambda-parameters)
   (list 'lambda-body lambda-body)
   ;; Let expressions
   (list 'let? let?)
   (list 'let->combination let->combination)
   ;; Begin expressions
   (list 'begin? begin?)
   (list 'begin-actions begin-actions)
   (list 'first-exp first-exp)
   (list 'rest-exps rest-exps)
   (list 'last-exp? last-exp?)
   (list 'no-more-exps? no-more-exps?)
   ;; Cond expressions
   (list 'cond? cond?)
   (list 'cond->if cond->if)
   ;; Applications/combinations
   (list 'application? application?)
   (list 'operator operator)
   (list 'operands operands)
   (list 'no-operands? no-operands?)
   (list 'first-operand first-operand)
   (list 'rest-operands rest-operands)
   (list 'last-operand? last-operand?)
   (list 'primitive-procedure? primitive-procedure?)
   (list 'compound-procedure? compound-procedure?)
   (list 'compiled-procedure? compiled-procedure?)
   (list 'apply-primitive-procedure apply-primitive-procedure)
   (list 'procedure-parameters procedure-parameters)
   (list 'procedure-body procedure-body)
   (list 'procedure-environment procedure-environment)
   (list 'compiled-procedure-entry compiled-procedure-entry)
   (list 'compiled-procedure-env compiled-procedure-env)
   (list 'empty-arglist empty-arglist)
   (list 'adjoin-arg adjoin-arg)))

(define (make-universal-machine)
  (let* ((operations-table univ-machine-ops-table)
         (pc (make-register 'pc))
         (flag (make-register 'flag))
         (continue (make-register 'continue))
         (exp (make-register 'exp))
         (unev (make-register 'unev))
         (proc (make-register 'proc))
         (arg1 (make-register 'arg1))
         (arg2 (make-register 'arg2))
         (argl (make-register 'argl))
         (env (make-register 'env))
         (val (make-register 'val))
         (compapp (make-register 'compapp)) ; added for Exercise 5.47
         (register-table 
          (list
           (list 'pc pc)
           (list 'flag flag)
           (list 'continue continue)
           (list 'exp exp)
           (list 'unev unev)
           (list 'proc proc)
           (list 'arg1 arg1)
           (list 'arg2 arg2)
           (list 'argl argl)
           (list 'env env)
           (list 'val val)
           (list 'compapp compapp))) ; added for Exercise 5.47
         (stack-table
          (list
           (list 'continue (make-stack))
           (list 'exp (make-stack))
           (list 'unev (make-stack))
           (list 'proc (make-stack))
           (list 'arg1 (make-stack))
           (list 'arg2 (make-stack))
           (list 'argl (make-stack))
           (list 'env (make-stack))
           (list 'val (make-stack))))
         (instruction-sequence 'waiting-for-input)
         (labels 'waiting-for-input)
         (instruction-counter 0)
         (instruction-tracing 'off)
         (label-tracing 'off))
    (define (get-register name)
      (let ((val (assoc name register-table)))
        (if val
            (cadr val)
            (error "Unknown register:" name))))
    (define (get-register-stack name)
      (let ((val (assoc name stack-table)))
        (if val
            (cadr val)
            (error "Unknown stack:" name))))
    (define (execute)
      (let ((insts (get-contents pc)))
        (if (null? insts)
            'done
            (begin
              (if (eq? 'on label-tracing)
                  (let ((preceding-labels
                         (map car (filter (lambda (lbl)
                                            (equal? insts (label-instructions lbl)))
                                          labels))))
                    (if (pair? preceding-labels)
                        (for-each pp preceding-labels))))
              (let ((first-inst (car insts)))
                (if (eq? 'on instruction-tracing)
                    (pp (instruction-text first-inst)))
                ((instruction-execution-proc first-inst))
                (set! instruction-counter (+ 1 instruction-counter)))
              (execute)))))
    (define (dispatch message)
      (cond ((eq? message 'start)
             (set-contents! pc instruction-sequence)
             (execute))
            ((eq? message 'install-program)
             (lambda (program)
               (let ((assembled-program (assemble program dispatch)))
                 (set! instruction-sequence
                   (instructions-with-exec-procs assembled-program))
                 (set! labels
                   (labels-with-entry-locations assembled-program)))))
            ((eq? message 'operations-table) operations-table)
            ((eq? message 'get-register) get-register)
            ((eq? message 'get-register-stack) get-register-stack)
            ((eq? message 'stack-table) stack-table)
            ((eq? message 'toggle-label-tracing)
             (if (eq? 'off label-tracing)
                 (set! label-tracing 'on)
                 (set! label-tracing 'off))
             label-tracing)
            ((eq? message 'toggle-instruction-tracing)
             (if (eq? 'off instruction-tracing)
                 (set! instruction-tracing 'on)
                 (set! instruction-tracing 'off))
             instruction-tracing)
            (else (error "Unknown request -- MACHINE" message))))
    dispatch))

(define (install-program machine program)
  ((machine 'install-program) program)
  machine)

(define (start machine)
  (machine 'start))

(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))

(define (set-register-contents! machine reg-name val)
  (set-contents! (get-register machine reg-name) val)
  'done)

(define (get-register-contents machine reg-name)
  (get-contents (get-register machine reg-name)))

(define (get-register-stack machine reg-name)
  ((machine 'get-register-stack) reg-name))

(define (toggle-register-tracing! machine reg-name)
  ((get-register machine reg-name) 'toggle-tracing))
